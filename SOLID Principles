The SOLID principles are five core design principles in object-oriented programming (OOP) that make software more maintainable, flexible, and scalable.

They were introduced by Robert C. Martin (Uncle Bob) and are widely used in Java, Spring Boot, and other OOP-based systems.

üß© S ‚Äî Single Responsibility Principle (SRP)

Definition:
A class should have only one reason to change, meaning it should have only one responsibility or job.

Example (Java):

// ‚ùå Violates SRP
class Invoice {
    void calculateTotal() { /* logic */ }
    void printInvoice() { /* logic */ }
    void saveToDatabase() { /* logic */ }
}

// ‚úÖ Follows SRP
class Invoice {
    void calculateTotal() { /* logic */ }
}

class InvoicePrinter {
    void print(Invoice invoice) { /* logic */ }
}

class InvoiceRepository {
    void save(Invoice invoice) { /* logic */ }
}


Why:
Easier to test, modify, and maintain. Each class focuses on one purpose.

‚öôÔ∏è O ‚Äî Open/Closed Principle (OCP)

Definition:
Classes should be open for extension but closed for modification.
You should be able to add new functionality without changing existing code.

Example (Java):

// ‚ùå Violates OCP
class AreaCalculator {
    double calculate(Object shape) {
        if (shape instanceof Circle)
            return Math.PI * ((Circle) shape).radius * ((Circle) shape).radius;
        else if (shape instanceof Rectangle)
            return ((Rectangle) shape).length * ((Rectangle) shape).width;
        return 0;
    }
}

// ‚úÖ Follows OCP
interface Shape {
    double area();
}

class Circle implements Shape {
    double radius;
    public double area() { return Math.PI * radius * radius; }
}

class Rectangle implements Shape {
    double length, width;
    public double area() { return length * width; }
}

class AreaCalculator {
    double calculate(Shape shape) { return shape.area(); }
}


Why:
You can add new shapes without touching AreaCalculator.

üß± L ‚Äî Liskov Substitution Principle (LSP)

Definition:
Subclasses should be replaceable by their base classes without breaking functionality.

Example (Java):

// ‚ùå Violates LSP
class Bird {
    void fly() {}
}

class Ostrich extends Bird {
    // Ostrich cannot fly ‚Äî breaks LSP
    void fly() { throw new UnsupportedOperationException(); }
}


‚úÖ Fix:

interface Bird {}
interface FlyingBird extends Bird { void fly(); }

class Sparrow implements FlyingBird {
    public void fly() { /* fly logic */ }
}

class Ostrich implements Bird { /* no fly */ }


Why:
Inheritance should not change expected behavior of parent class.

üîå I ‚Äî Interface Segregation Principle (ISP)

Definition:
No client should be forced to depend on methods it does not use.
Create smaller, specific interfaces instead of large, general ones.

Example (Java):

// ‚ùå Violates ISP
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { /* logic */ }
    public void eat() { /* not applicable */ } // violates
}

// ‚úÖ Follows ISP
interface Workable { void work(); }
interface Eatable { void eat(); }

class Human implements Workable, Eatable { /* both */ }
class Robot implements Workable { /* only work */ }


Why:
Avoid unnecessary method implementation.

üß† D ‚Äî Dependency Inversion Principle (DIP)

Definition:
High-level modules should not depend on low-level modules.
Both should depend on abstractions (interfaces).

Example (Java):

// ‚ùå Violates DIP
class MySQLDatabase {
    void connect() {}
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase(); // tightly coupled
    void saveUser() { db.connect(); }
}

// ‚úÖ Follows DIP
interface Database {
    void connect();
}

class MySQLDatabase implements Database {
    public void connect() {}
}

class UserService {
    private Database db;
    UserService(Database db) { this.db = db; }
    void saveUser() { db.connect(); }
}


Why:
Makes your system loosely coupled and easier to test (e.g., with mocks).

‚úÖ Summary Table
Principle	Meaning	Benefit
S	Single Responsibility	One class = One job
O	Open/Closed	Extend without modifying
L	Liskov Substitution	Derived classes behave like base
I	Interface Segregation	Small, focused interfaces
D	Dependency Inversion	Depend on abstractions, not concretes
